# eBPF 的一些概念

* <https://lwn.net/Articles/603983/>

**eBPF** 的前身是 **BPF**，BPF 最初被设计用于捕获和过滤与特定规则匹配的网络数据包，被实现在基于寄存器的虚拟机上执行的程序。eBPF 在 BPF 的基础上进行了拓展，实现了更多的功能。使用 eBPF 可以允许在内核态执行沙盒程序，从而可以在不更改内核源码或者加载内核模块的情况下实现一些适合在内核态完成的工作，比如网络性能、防火墙、安全性、追踪、设备驱动等。

eBPF 在内核中是事件驱动的，可以 hook 到不同的事件点（例如收发 `socket` 消息），在发生这些事件的时候执行 eBPF 程序。

eBPF 的虚拟机具有 10 个寄存器，以及其特定的栈，可以通过指令对这些寄存器的值、栈以及内存进行操作。

Linux 内核以字节码的形式加载 eBPF 程序，通常使用伪 C 代码编写 eBPF 程序，然后使用编译器编译成 eBPF 字节码。eBPF 程序的指令形式如下所示：

```c
BPF_MOV64_IMM(BPF_REG_3, 1)  // 将立即数 1 放置到第 3 个寄存器中
BPF_ALU64_REG(BPF_ARSH, BPF_REG_7, BPF_REG_5)  // 将寄存器 7 的值算术右移寄存器 5 的值
BPF_JMP_IMM(BPF_JNE, BPF_REG_3, 0, 3)  // 分支跳转：如果寄存器 3 的值不等于 0，则跳过 3 条指令
BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_9, 24)  // 从寄存器 9 + 24 的地址处加载数据到寄存器 3
BPF_STX_MEM(BPF_DW, BPF_REG_8, BPF_REG_6, 0)  // 将寄存器 6 的值存放到寄存器 8 所处的地址处
```

eBPF 程序通过 `bpf` 系统调用传递给内核态，`bpf` 系统调用定义如下：

```c
int bpf(int cmd, union bpf_attr *attr, unsigned int size);
```

其中 `cmd` 表示各种命令，可以由用户态指定。比如 **BPF_PROG_LOAD** 命令可以将 eBPF 程序加载到内核态中。执行该命令之后会返回一个文件描述符，如果将该文件描述符与一个 `socket` 关联，就可以对该 `socket` 数据进行过滤；**BPF_MAP_CREATE** 命令可以创建 Maps，Maps 是存储数据的键值对，可以用来做 eBPF 程序和内核与用户空间之间进行数据传递。

当 eBPF 程序通过 **BPF_PROG_LOAD** 命令被加载到内核之后，会经历两个阶段： **验证（Verification）** 和 **JIT 编译**。其中 JIT 编译阶段将字节码翻译成机器指令，从而使得 eBPF 可以更高效地执行。

验证阶段确保所执行的 eBPF 程序是安全的：

* 除非开启了非特权 eBPF，否则只有特权级进程才能加载 eBPF 程序
* 这个 eBPF 程序不会对系统造成危害：模拟一次执行，每条指令执行都检查虚拟机状态，确保状态的安全
* 这个 eBPF 程序不会阻塞（死循环）
* **不能对指针进行超过指针可控制内存范围的算术运算**
* ...

为此，验证阶段必须针对每个程序指令，跟踪哪个寄存器包含指针，哪个寄存器包含标量值等。同时，为了防止越界读写，需要对寄存器中的指针值进行范围计算，对标量值进行范围追踪，使得对内存的访问不会超过其边界。为了确定寄存器中的值的边界，需要对以下 3 个单独的边界进行追踪（其实跟 **V8** 的类型整数类型推导阶段差不多）：

1. `umin` 和 `umax`：当解释器将寄存器的值解释为无符号整数时的最小值和最大值
2. `smin` 和 `smax`：当解释器将寄存器的值解释为有符号整数时的最小值和最大值
3. `var_off`：是一个结构体（`tnum`），表示可以包含的值的二进制的形式，比如 `var_off.value = 010`，`var_off.mask = 100`，则该寄存器可以包含 `010` 和 `110`（跟子网掩码的形式差不多），即 `mask` 为 `1` 的位表示该 `value` 位不确定，当 `mask` 为 `0` 表示该位取值确定。

上述这 3 个追踪的值可以相互更新，例如如果 `umax` 小于 `2^63`，则 `smin` 会被设置为 `0`（因为不会有负数出现），如果 `var_off` 指示寄存器只有最低 3 位可能为 `1`，则 `umax` 为 `7`。