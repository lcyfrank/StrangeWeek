# Papers

一些使用静态程序分析的方式来进行漏洞挖掘的工作，其他方式进行漏洞挖掘的工作可以参看：

* [Fuzzing](../Fuzzing/)：模糊测试相关的一些学习记录；
* [Deep Learning](../DLP/Vulnerability.md)：借助深度学习来进行漏洞挖掘的一些工作记录；

论文列表：

* [Understanding and Detecting Disordered Error Handling with Precise Function Pairing](#understanding-and-detecting-disordered-error-handling-with-precise-function-pairing)：通过函数对匹配的方式检测程序错误处理路径中的由于不匹配的操作或者操作序列导致的漏洞

---

## Understanding and Detecting Disordered Error Handling with Precise Function Pairing

*30th {USENIX} Security Symposium ({USENIX} Security 21). 2021.*

这篇文章作者主要聚焦于程序中普遍存在的错误处理过程中出现的一些新的漏洞。错误处理由于其本身的复杂性，经常会出现一些比较严重的漏洞，作者提到之前的相关工作都专注于类似返回不正确的错误码，或者在错误传递过程中缺失一些信息等问题。而作者这篇文章主要针对错误处理之前进行的 `cleanup` 操作，作者发现这些操作可能会因为不正确的操作顺序、多余的操作或者不足的操作而引起一些比较严重的漏洞，作者将这一系列的漏洞命名为 **DiEH** 漏洞，并开发了一个针对该类漏洞的检测系统 **HERO**。

作者首先对相关的工作进行了调研，发现在 **Linux** 内核的漏洞中，有 `34%` 的漏洞是跟错误处理流程相关的，过去也有工作针对错误处理流程进行安全性分析，但是这些工作没有针对错误处理流程之前的这些操作（比如 `cleanup` 操作）进行安全性分析的。作者提到，在程序处理错误之前，通常会进行一系列的 `cleanup` 操作，例如释放相关的内存等。

作者定义了 **Leader Function** 和 **Follower Function** 的概念。**Leader Function** 对一些资源进行初始化（例如申请内存 / 获得锁等），而 **Follower Function** 则对资源进行恢复（例如释放内存 / 释放锁）。这两个函数最终构成一个函数对。作者还对错误处理结构进行了统一化的定义，在处理错误之前，**Leader Function** 和 **Follower Function** 以一个栈的形式进行配对调用（例如最初申请的资源在最后释放），因此作者将其描述成为一个栈结构。而在一段代码中，可能会有很多这样的路径（栈），这些路径不一定相同，作者将这些路径之间的差别定义为 **EH delta**，而函数对就通过 **EH delta** 来识别：

<img src="./img/hero/eh_def.png" width="600px">

上图中的数字代表代码行（即上述的 **Leader Function** 和 **Follower Function** 所在的行），白色的圆点代表正常的执行路径，黑色的圆点代表发生错误的代码，灰色的圆点代表错误处理路径。

接着，作者正式定义了 **DiEH** 漏洞，这种漏洞是在 **Follower Function** 在不正确的顺序被调用的情况下，或者被多余调用、调用不足的情况下发生的。作者通过当前 **Follower Function** 列表与期待的列表对比来检测该漏洞，因此主要的关键点在于提取期待的 **Follower Function** 列表。而作者通过手动分析 **Linux** 内核的 **CVE** 发现，有较多的漏洞是与 **DiEH** 相关的。

为了可以检测出 **DiEH** 漏洞，作者提出了叫做 **HERO** 的方法。首先，需要提取出统一化的错误处理结构。这里有一个比较困难的地方是如何定位到正常的执行路径和错误处理执行路径，以及如何将这两个执行路径对应起来。（因为一个函数中可能有很多正常的执行路径和错误处理路径，但是他们并不是互相关联的）。此外，还需要分别从这两个路径中提取出 **Leader Function** 和 **Follower Function**，同时还需要构造期待的 **Follower Function** 序列。最后，还要考虑有一些与期待序列不匹配，但是不存在漏洞的情况，对这些误报进行消除。

总的来说，**HERO** 分成 4 个部分，首先从源码中提取 **CFG** 和 **Call Graph**，然后提取出错误处理结构，构造 **EHG**，然后提取出函数对，并得到 **Follower Function** 序列，最后通过序列的匹配来检测漏洞。如下图所示：

<img src="./img/hero/hero_overview.png" width="900px">

接下来作者分别对这 4 个阶段进行了详细的介绍。

为了提取出错误处理结构，作者首先对错误检查的相关代码进行定位。作者通过预先收集通用的错误码，错误处理函数等。如果这条路径返回了某个错误码或者调用了错误处理函数，则认为这条路径是错误路径。通过定位到这样一个错误检查的代码，可以同时收集到正常路径和错误路径（*这里其实没太明白，总感觉这么处理有点粗糙*）。

在初步得到两个路径之后，还需要对无关函数进行过滤。作者发现，错误处理中的代码通常是比较简单的，无关的函数通常就是一些常见的函数，因此作者首先通过函数匹配对错误处理路径中的无关函数进行过滤，然后对于正常路径中的函数，由于 **Leader Function** 和 **Follower Function** 通常需要通过一个变量相连，因此，作者这里使用了数据依赖的方式，从错误路径中的函数反推回正常路径中的函数，从而过滤掉无关函数。（*这个过滤方式是不是有点粗糙了？*）

之后，作者对于每一个错误检查点构造一个错误处理栈（EHS），依据 CFG 中的控制流连接关系，最终构造出一个 **EHG**，如下图所示：

<img src="./img/hero/ehg_sample.png" width="600px">

之后，对于相邻节点，计算一个 **EH delta** 来提取函数对（*基本思想应该是作者认为相邻的错误处理逻辑可能就相差一个资源的管理？*）。

在提取到函数对之后，就可以用函数对来进行 **DiEH** 漏洞检测（*但是文中作者好像没有提到是如何计算期待序列的？*）。这样检测出来的漏洞可能会存在假阳性的情况，因为有一些错误处理路径会有相应的约束使得漏洞路径无法被满足，作者在这里提出了 `symbolic summary` 的方法，对路径上相关的约束进行提取，然后检查约束之间是否冲突，本质上是一种轻量的符号执行的方案，但是仅考虑当前函数中相关的约束，因此开销远远小于符号执行。此外，作者还发现对于顺序不一致的 **Follower Function** 序列漏洞来说，如果两个 **Follower Function** 之间不存在数据依赖关系，则可能也是一个误报。

在实验阶段，作者首先评估了其函数对提取方法的准确性，通过手动确认之后，作者发现直接的函数对提取确实准确率较低（89 / 150），因此作者还提出了一种函数对排名的机制，来更进一步根据函数在工程中出现的次数对函数对进行排名，从而提升了准确性。

作者最后将 **HERO** 部署到 **Linux**、**FreeBSD** 和 **OpenSSL** 上进行漏洞检测，分别发现了 234、2、3 个漏洞。作者还提供了对这些漏洞进行自动化触发的方案。