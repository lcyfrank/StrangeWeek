# V8 学习笔记

## 漏洞分析链接

* <https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/>
    * 一个 `Math.expm1` 的漏洞，会在优化（JIT）之后导致 `Object.is(Math.expm1(-0), -0)` 返回 `false`。大致是因为 `Math.expm1` 在经过 `JIT` 优化时，会使得 `Math.expm1` 的返回类型被标记成（PlainNumber, NaN）这样的联合体，但是 -0 不属于上述联合体，因此 `Object.is` 会直接返回 false。
* <http://www.phrack.org/papers/jit_exploitation.html>
    * CVE-2018-17463，安全检查冗余消除导致的漏洞，此外这篇文章还讲解了一些 V8 的基础知识。漏洞是 V8 将 `CreateObject` 对应的操作标记成无副作用的（但实际上会改变对象的 Maps，使得对象的 `Out-line` 属性的类型从 `Array` 形式变成 `Dictionary` 形式，这时 `In-line` 的属性也会被放到 `Out-line` 属性中），因此如果对含有 `CreateObject` （`Object.create`）调用的函数一开始触发了对对象的 Maps 的检查，那么之后的检查就会被冗余消除优化删去，再结合 `CreateObject` 实际的副作用，最终可以导致 `Out-line` 属性的 `Overlap`，这样就能构造出 **Type Confusion**，从而进一步利用。

## 其他学习链接

1. <https://es6.ruanyifeng.com/>
    * ES6 学习教程
2. <https://www.freebuf.com/vuls/203721.html>
    * 从一到 CTF 题理解 V8 漏洞的利用，零基础入门题目，提供 `oob` 方法存在一索引越界读写漏洞
3. <https://e3pem.github.io/2019/11/20/browser/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E7%BA%BF%E4%B8%8B-Browser/>
    * 虽说是 CTF 题，但是这题的漏洞比较巧妙，提供的 coin 方法中存在可以通过 `valueOf` 回调改写数组大小从而导致越界写的漏洞
    * 拓展（通过内存越界，构造 Victim Object，来获得 addr_of 原语可参照该链接）：<https://xz.aliyun.com/t/6577>
4. <https://paper.seebug.org/1145/>
    * 也是 CTF 题，但是属于真实漏洞。属于存在数组越界访问的漏洞，其实原理跟「3」差不多，也是在执行过程中忽略了可以调用用户自定义的方法，然后在自定义方法中将数组大小做改变，从而构造越界读写。但是这篇文章还讲解了对代码的分析。不过文章中有一些错误，在 JavaScript 以 `.call` 形式调用函数时，`call` 中的第一个参数在解析时作为 Receiver，而第二个参数才是真正的下标 0 的参数。此外，这个漏洞还使用了到了 JS 中的迭代对象的概念，不清楚的可以参考「学习链接 1」。
    * 拓展链接（1）：<https://www.anquanke.com/post/id/147829> 这个劫持控制流思路是自定义一个函数，然后使其 JIT，之后改写这个函数地址的内容
    * 拓展链接（2）：<https://www.sunxiaokong.xyz/2020-01-16/lzx-roll-a-d8/> 有对相关 JS 语法的讲解
    * 拓展链接（3）：<https://xz.aliyun.com/t/5190> 这个劫持控制流思路是泄漏堆地址和栈地址，通过堆地址搜索泄漏 `libc` 地址，然后通过 `ArrayBuffer` 布置 Shellcode，之后通过 ROP 将布置 Shellcode 的地址设置为可执行，最后跳转到 Shellcode 进行执行
5. <https://esprima.org/doc/>
    * 根据 JavaScript 源代码生成抽象语法树（AST）
6. <https://juejin.im/post/5dc4d823f265da4d4c202d3b?from=groupmessage>
    * 对 V8 的执行和 GC 进行了一个概述性质的介绍
7. <https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8#excurse-value-representation>
    * 针对 V8 `Ignition` 和 `TurboFan` 优化（主要是 IC 和 Feedback Vector）的详细讲解
8. <https://animal0day.blogspot.com/2020/04/setting-up-vulnerable-v8-on-windows.html>
    * 构建 Windows 下的 V8 调试环境

## 配置 V8 环境

* <https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html>

可以参考上述链接完成。

首先，需要配置 `git` 本地代理：

```sh
$ git config —global http.proxy http://ip:port
$ git config —global https.proxy http://ip:port
```

然后，需要配置环境变量代理（因为后续命令会用到 `curl`）：

```sh
$ export http_proxy=“http://ip:port”
$ export https_proxy = “http://ip:port”
```

之后，下载 `depot_tools`：

```sh
$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
$ export PATH=/path/to/depot_tools:$PATH
```

然后，安装 `Ninja`，为编译做准备：

```sh
$ git clone https://github.com/ninja-build/ninja.git
$ cd ninja && ./configure.py —bootstrap && cd ..
$ export PATH=/path/to/ninja:$PATH
```

最后，调用 `fetch v8` 即可拉取 V8 代码。

拉取代码之后，切换到需要调试的版本 / 分支，之后执行 `gclient sync` 来同步一些编译时需要的文件 / 配置。如果是在 Linux 下执行，则还需调用 `./build/install-build-deps.sh` 进行一些依赖的下载。（`gclient sync` 如果报需要 `config` 的错误，可以先执行这个命令：`gclient config https://chromium.googlesource.com/v8/v8`）

之后执行 `tools/dev/v8gen.py x64.release` 或者 `tools/dev/v8gen.py x64.debug` 生成构建的配置，最后执行 `ninja -C out.gn/x64.release` 或者 `ninja -C out.gn/x64.debug` 开始编译，完成构建。

如果想要在 `release` 的情况下获得调试信息（即在 `gdb` 中用 `job` 命令对内存进行打印），可以在生成构建配置之后，编辑 `x64.release/args.gn`，添加以下内容：

```sh
v8_enable_backtrace = true
v8_enable_disassembler = true
v8_enable_object_print = true
v8_enable_verify_heap = true
```